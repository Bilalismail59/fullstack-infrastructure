name: Deploy to Google Cloud Platform

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main

env:
  GCP_PROJECT_ID: primordial-port-462408-q7
  GCP_REGION: europe-west1
  GCP_ZONE: europe-west1-b
  TERRAFORM_VERSION: 1.5.0

jobs:
  sonarqube-analysis:
    name: SonarQube Analysis
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Check if frontend exists
        id: check_frontend
        run: |
          if [ -d "frontend" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Frontend directory does not exist, skipping npm steps"
          fi

      - name: Cache node_modules
        if: steps.check_frontend.outputs.exists == 'true'
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ runner.os }}-npm-cache-${{ hashFiles('frontend/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-npm-cache-

      - name: Install dependencies with retry
        if: steps.check_frontend.outputs.exists == 'true'
        run: |
          cd frontend
          for i in 1 2 3 4 5; do
            echo "Attempt $i"
            npm cache clean --force
            npm ci && break
            echo "Retrying in 15 seconds..."
            sleep 15
          done   

      - name: Run tests with coverage
        if: steps.check_frontend.outputs.exists == 'true'
        run: |
          cd frontend
          npx vitest run --coverage

  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: sonarqube-analysis
    strategy:
      matrix:
        environment: [preprod, prod]
    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup Google Cloud CLI 
        uses: google-github-actions/setup-gcloud@v1
        with: 
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Create service account key file
        run: |
          cd terraform
          echo '${{ secrets.GCP_SA_KEY }}' > service-account-key.json

      - name: Verify GCS bucket exists
        run: |
          BUCKET="${{ secrets.TERRAFORM_STATE_BUCKET }}"
          if ! gsutil ls -b gs://$BUCKET >/dev/null 2>&1; then
            echo "Creating Terraform state bucket: $BUCKET"
            gsutil mb -p ${{ env.GCP_PROJECT_ID }} -l ${{ env.GCP_REGION }} gs://$BUCKET
            gsutil versioning set on gs://$BUCKET
          else
            echo "Terraform state bucket exists: $BUCKET"
          fi

      - name: Configure Terraform Backend
        run: |
          cd terraform
          # Hardcode the bucket name and prefix directly
          cat > backend.tf << EOF
          terraform {
            backend "gcs" {
              bucket = "${{ secrets.TERRAFORM_STATE_BUCKET }}"
              prefix = "${{ matrix.environment }}/terraform/state"
            }
          }
          EOF
          
          # Debug: Show what was written to the file
          echo "Content of backend.tf:"
          cat backend.tf

      - name: Terraform Init with reconfigure
        run: |
          cd terraform
          # Force reconfiguration of the backend
          terraform init -reconfigure

      - name: Terraform Plan
        run: |
          cd terraform
          terraform plan \
            -var="environment=${{ matrix.environment }}" \
            -var="project_id=${{ env.GCP_PROJECT_ID }}" \
            -var="region=${{ env.GCP_REGION }}" \
            -var="zone=${{ env.GCP_ZONE }}" \
            -var="db_password=${{ secrets.DB_PASSWORD }}" \
            -var="domain_name=${{ secrets.DOMAIN_NAME }}" \
            -out=tfplan-${{ matrix.environment }}

      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ matrix.environment }}
          path: terraform/tfplan-${{ matrix.environment }}

  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: terraform-plan
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    strategy:
      matrix:
        environment: [preprod, prod]
    environment: ${{ matrix.environment }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup Google Cloud CLI
        uses: google-github-actions/setup-gcloud@v1
        with:  
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Download Terraform Plan
        uses: actions/download-artifact@v4
        with:
          name: tfplan-${{ matrix.environment }}
          path: terraform/

      - name: Create service account key file
        run: |
          cd terraform
          echo '${{ secrets.GCP_SA_KEY }}' > service-account-key.json

      - name: Configure Terraform Backend
        run: |
          cd terraform
          # Hardcode the bucket name and prefix directly
          cat > backend.tf << EOF
          terraform {
            backend "gcs" {
              bucket = "${{ secrets.TERRAFORM_STATE_BUCKET }}"
              prefix = "${{ matrix.environment }}/terraform/state"
            }
          }
          EOF
          
          # Debug: Show what was written to the file
          echo "Content of backend.tf:"
          cat backend.tf

      - name: Terraform Init with reconfigure
        run: |
          cd terraform
          # Force reconfiguration of the backend
          terraform init -reconfigure

      - name: Import all existing resources
        run: |
          cd terraform
          set +e
          
          echo "=== Phase 1: Nettoyage sélectif des ressources problématiques ==="
          
          # Fonction pour supprimer une ressource si elle existe
          delete_if_exists() {
            local resource_type=$1
            local resource_name=$2
            local delete_command=$3
            
            echo "Vérification de $resource_name..."
            if eval "$delete_command --dry-run" 2>/dev/null; then
              echo "Suppression de $resource_name..."
              eval "$delete_command --quiet" || echo "Échec suppression $resource_name"
            else
              echo "$resource_name n'existe pas ou déjà supprimé"
            fi
          }
          
          # Supprimer uniquement les ressources qui causent des conflits
          delete_if_exists "firewall" "fullstack-app-allow-http" "gcloud compute firewall-rules delete fullstack-app-allow-http"
          delete_if_exists "firewall" "fullstack-app-allow-ssh" "gcloud compute firewall-rules delete fullstack-app-allow-ssh"  
          delete_if_exists "firewall" "fullstack-app-allow-internal" "gcloud compute firewall-rules delete fullstack-app-allow-internal"
          delete_if_exists "firewall" "fullstack-app-allow-monitoring" "gcloud compute firewall-rules delete fullstack-app-allow-monitoring"
          delete_if_exists "subnet" "fullstack-app-web-subnet" "gcloud compute networks subnets delete fullstack-app-web-subnet --region=${{ env.GCP_REGION }}"
          delete_if_exists "subnet" "fullstack-app-db-subnet" "gcloud compute networks subnets delete fullstack-app-db-subnet --region=${{ env.GCP_REGION }}"
          delete_if_exists "address" "fullstack-app-private-ip" "gcloud compute addresses delete fullstack-app-private-ip --global"
          
          echo "=== Phase 2: Import des ressources existantes ==="
          
          # Fonction d'import avec retry
          import_resource() {
            local tf_resource=$1
            local gcp_resource=$2
            local max_attempts=3
            
            echo "Import de $tf_resource..."
            
            # Supprimer de l'état si existant
            terraform state rm "$tf_resource" 2>/dev/null || true
            
            # Tentatives d'import
            for attempt in $(seq 1 $max_attempts); do
              echo "Tentative $attempt/$max_attempts pour $tf_resource"
              if terraform import "$tf_resource" "$gcp_resource" 2>/dev/null; then
                echo " Import réussi pour $tf_resource"
                return 0
              else
                echo " Échec tentative $attempt pour $tf_resource"
                sleep 5
              fi
            done
            
            echo " Import définitivement échoué pour $tf_resource"
            return 1
          }
          
          # Import des ressources critiques (celles qui ne causent pas de conflits)
          import_resource "google_compute_network.main" "projects/${{ env.GCP_PROJECT_ID }}/global/networks/fullstack-app-vpc"
          import_resource "google_compute_health_check.frontend" "projects/${{ env.GCP_PROJECT_ID }}/global/healthChecks/fullstack-app-frontend-hc"
          import_resource "google_compute_health_check.backend" "projects/${{ env.GCP_PROJECT_ID }}/global/healthChecks/fullstack-app-backend-hc"
          import_resource "google_compute_global_address.default" "projects/${{ env.GCP_PROJECT_ID }}/global/addresses/fullstack-app-lb-ip"
          import_resource "google_service_account.compute" "projects/${{ env.GCP_PROJECT_ID }}/serviceAccounts/fullstack-app-compute-sa@${{ env.GCP_PROJECT_ID }}.iam.gserviceaccount.com"
          
          echo "=== Phase 3: Nettoyage de l'état Terraform ==="
          
          # Nettoyer l'état des ressources qui vont être recréées
          terraform state rm "google_compute_subnetwork.web" 2>/dev/null || true
          terraform state rm "google_compute_subnetwork.db" 2>/dev/null || true
          terraform state rm "google_compute_firewall.allow_http" 2>/dev/null || true
          terraform state rm "google_compute_firewall.allow_ssh" 2>/dev/null || true
          terraform state rm "google_compute_firewall.allow_internal" 2>/dev/null || true
          terraform state rm "google_compute_firewall.allow_monitoring" 2>/dev/null || true
          terraform state rm "google_compute_global_address.private_ip_address" 2>/dev/null || true
          
          set -e
          echo "=== Import terminé ==="

      - name: Terraform Apply
        run: |
          cd terraform
          terraform apply -auto-approve tfplan-${{ matrix.environment }}

  build-and-deploy:
    name: Build and Deploy Application
    runs-on: ubuntu-latest
    needs: terraform-apply
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    strategy:
      matrix:
        environment: [preprod, prod]
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup Google Cloud CLI
        uses: google-github-actions/setup-gcloud@v1
        with:    
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Configure Docker for GCR
        run: gcloud auth configure-docker

      - name: Build Frontend Docker Image
        run: |
          cd frontend
          docker build -t gcr.io/${{ env.GCP_PROJECT_ID }}/frontend:${{ github.sha }} .
          docker push gcr.io/${{ env.GCP_PROJECT_ID }}/frontend:${{ github.sha }}

      - name: Deploy to GKE (Production only)
        if: matrix.environment == 'prod'
        run: |
          gcloud container clusters get-credentials fullstack-app-gke-cluster --region=${{ env.GCP_REGION }}
          kubectl set image deployment/frontend-deployment frontend=gcr.io/${{ env.GCP_PROJECT_ID }}/frontend:${{ github.sha }}
          kubectl rollout status deployment/frontend-deployment
          kubectl rollout status deployment/backend-deployment

      - name: Update Compute Engine instances
        if: matrix.environment == 'preprod'
        run: |
          INSTANCE_GROUP=$(gcloud compute instance-groups managed list --filter="name~fullstack-app-frontend" --format="value(name)" --limit=1)
          gcloud compute instance-groups managed rolling-action start-update $INSTANCE_GROUP \
            --version=template=fullstack-app-frontend-$(date +%s) \
            --zone=${{ env.GCP_ZONE }}

  monitoring-setup:
    name: Setup Monitoring
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup Google Cloud CLI
        uses: google-github-actions/setup-gcloud@v1
        with:    
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Create Monitoring Dashboards
        run: |
          gcloud monitoring dashboards create --config-from-file=monitoring/gcp-dashboard.json

      - name: Setup Alerting Policies
        run: |
          gcloud alpha monitoring policies create --policy-from-file=monitoring/alert-policies.yaml

  notify-deployment:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [monitoring-setup]
    if: always()
    steps:
      - name: Notify Slack
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          text: |
            Deployment to GCP completed!
            Environment: production
            Status: ${{ job.status }}
            Commit: ${{ github.sha }}
        env:
         SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }} 

      - name: Log deployment status
        run: |
          echo "Deployment completed with status: ${{ job.status }}"
          echo "Slack notification sent if webhook was configured."
